diff --git a/posixrealtime.c b/posixrealtime.c
index 8f7c197..13c9a24 100644
--- a/posixrealtime.c
+++ b/posixrealtime.c
@@ -89,20 +89,21 @@ static char * timespec_to_string(struct timespec const * ts_p)
     if (!result_p) {
         php_error_docref(NULL TSRMLS_CC, E_ERROR, "Failed to allocate memory [%s] (%s)", __func__, strerror(errno));
         return NULL;
     }
 
     snprintf(result_p, result_sz, "%jd.%ld", (intmax_t) ts_p->tv_sec, decimal);
 
     return result_p;
 }
 
+#if PHP_MAJOR_VERSION < 7
 static zval * timespec_to_zval(struct timespec const * ts_p)
 {
 #    ifdef ZTS
     TSRMLS_FETCH();
 #    endif
     
     long nsec = ts_p->tv_nsec;
     zval * obj_p;
 
     MAKE_STD_ZVAL(obj_p);
@@ -114,20 +115,21 @@ static zval * timespec_to_zval(struct timespec const * ts_p)
     } else {
         char secstr[(size_t) (INTLEN(ts_p->tv_sec) + 1)];
         snprintf(secstr, sizeof (secstr), "%d", ts_p->tv_sec);
         add_property_string(obj_p, "tv_sec", secstr, 0);
     }
 
     add_property_long(obj_p, "tv_nsec", nsec);
 
     return obj_p;
 }
+#endif
 
 /*
  * PHP callbacks
  */
 
 PHP_MINIT_FUNCTION(posixrealtime)
 {
     REGISTER_LONG_CONSTANT("PSXRT_AS_TIMESPEC", TIMESPEC, CONSTFLAGS);
     REGISTER_LONG_CONSTANT("PSXRT_AS_FLOAT", FLOAT, CONSTFLAGS);
     REGISTER_LONG_CONSTANT("PSXRT_AS_STRING", STRING, CONSTFLAGS);
@@ -270,33 +272,67 @@ PHP_FUNCTION(posix_clock_gettime)
             }
             floor_to_ns = clock_res.tv_nsec;
         }
         clock_val_nsec_raw = clock_val.tv_nsec;
         clock_val.tv_nsec -= clock_val.tv_nsec % floor_to_ns;
     }
 
     switch (return_type) {
     case TIMESPEC:
     {
+#if PHP_MAJOR_VERSION < 7
         zval * obj_p = timespec_to_zval(&clock_val);
         if (floor_to_ns) {
             add_property_long(obj_p, "floored_to_nsec", floor_to_ns);
             add_property_long(obj_p, "tv_nsec_raw", clock_val_nsec_raw);
         }
         RETURN_ZVAL(obj_p, 0, 1);
+#else
+        zval obj;
+        long nsec;
+
+#    ifdef ZTS
+        TSRMLS_FETCH();
+#    endif
+
+        nsec = clock_val.tv_nsec;
+
+        object_init(&obj);
+
+        // TODO: Check value against LONG_MAX instead?
+        if (sizeof (clock_val.tv_sec) <= SIZEOF_LONG) {
+            add_property_long(&obj, "tv_sec", clock_val.tv_sec);
+        } else {
+            char secstr[(size_t) (INTLEN(clock_val.tv_sec) + 1)];
+            snprintf(secstr, sizeof (secstr), "%d", clock_val.tv_sec);
+            add_property_string(&obj, "tv_sec", secstr);
+        }
+
+        add_property_long(&obj, "tv_nsec", nsec);
+
+        if (floor_to_ns) {
+            add_property_long(&obj, "floored_to_nsec", floor_to_ns);
+            add_property_long(&obj, "tv_nsec_raw", clock_val_nsec_raw);
+        }
+        RETURN_ZVAL(&obj, 1, 0);
+#endif
         break;
     }
     case FLOAT:
         RETURN_DOUBLE(TIMESPEC_TO_DOUBLE(clock_val));
         break;
     case STRING:
+#if PHP_MAJOR_VERSION >= 7
+        RETURN_STRING(timespec_to_string(&clock_val));
+#else
         RETURN_STRING(timespec_to_string(&clock_val), 0);
+#endif
         break;
     default:
         php_error_docref(NULL TSRMLS_CC, E_ERROR, "Return type must be one of: PSXRT_AS_TIMESPEC, "
                 "PSXRT_AS_FLOAT, PSXRT_AS_STRING");
         return;
     }
 }
 
 PHP_FUNCTION(posix_clock_getres)
 {
